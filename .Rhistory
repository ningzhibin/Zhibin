library(ggolt2)
library(ggpolt2)
library(ggplot2)
library(Zhibin)
library(Zhibin)
library(Zhibin)
library(Zhibin)
library(Zhibin)
library(Zhibin)
install.packages.auto(SilkSVN)
library(SilkSVN)
t <- read.delim("clipboard", header =  T)
fix(t)
table(t)
summmary(t)
summary(t)
Summarize(t)
summarize(t)
library(MASS)
attach(t)
t
colnames(t)
colnames(t) <- c("hours", "type")
attach(t)
aggreate(hours, type, sum
)
aggregate(hours, type, sum)
aggregate(hours, list(type), sum)
?aggregate
aggregate(t, list(type), sum)
aggregate(t, by = list(type), sum)
testDF <- data.frame(v1 = c(1,3,5,7,8,3,5,NA,4,5,7,9),
v2 = c(11,33,55,77,88,33,55,NA,44,55,77,99) )
by1 <- c("red", "blue", 1, 2, NA, "big", 1, 2, "red", 1, NA, 12)
by2 <- c("wet", "dry", 99, 95, NA, "damp", 95, 99, "red", 99, NA, NA)
aggregate(x = testDF, by = list(by1, by2), FUN = "mean")
head(testDF)
by1
aggregate(t, by = list(t$type), sum)
list(t$type)
by2
list(by1, by2)
testDF
aggregate(x = testDF, by = list(by1, by2), FUN = "mean")
fix(state.x77)
colnames(state.x77)
a <- list(Region = state.region,
Cold = state.x77[,"Frost"] > 130)
a
head(state.x77)
aggregate(t, by = list(t$type), sum)
aggregate(t, list(type), sum)
aggregate(hours, list(type), sum)
aggregate(t$hours), list(type), sum)
aggregate(t$hours, list(type), sum)
aggregate(t$hours, list(t$type), sum)
aggregate(t$hours, t$type, sum)
aggregate(t$hours, list(t$type), sum)
aggregate(t$hours, list(t$type), sum) ->ta
write.table(ta,"clipboard")
write.table(ta,"clipboard", sep="\t")
qe <-read.delim("clipboard", header = TREU)
qe <-read.delim("clipboard", header = TRUE)
head(qe)
qea<- aggregate(qe$hours, list(qe$type),sum)
write.table(qea,"clipboard", sep="\t")
xl <-read.delim("clipboard", header = TRUE)
xla<- aggregate(xl$hours, list(xl$type),sum)
head(xl)
xla<- aggregate(xl$hour, list(xl$type),sum)
write.table(xla,"clipboard", sep="\t")
hfx <-read.delim("clipboard", header = TRUE)
hfxa<- aggregate(hfx$hour, list(hfx$type),sum)
write.table(hfxa,"clipboard", sep="\t")
xl
xla
aa <- read.delim("clipboard", header = T)
head(aa)
?substr
substr("abcd", length("abcd")-1, 1)
substr("abcd", length("abcd")-1,length("abcd") )
length("abcd")-1
nchar("abcd")-1
substr("abcd", nchar("abcd")-1,1 )
substr("abcd", nchar("abcd")-1,nchar("abcd") )
substr("abcd", nchar("abcd"),nchar("abcd") )
substr("abcd", 3,3
)
substr("abcd", 3,4)
substr("abcd", 4,4)
apply(aa$Sequence,substr(x, nchar(x),nchar(x) ) )
?apply\
?apply
lapply(aa$Sequence,substr(x, nchar(x),nchar(x) ) )
lapply(aa$Sequence,function(x) substr(x, nchar(x),nchar(x) ) )
aa$Sequence
aa$Sequence <- as.charactor(aa$Sequence)
aa$Sequence <- as.character(aa$Sequence)
lapply(aa$Sequence,function(x) substr(x, nchar(x),nchar(x) ) )
LA <- sapply(aa$Sequence,function(x) substr(x, nchar(x),nchar(x) ) )
head(LA)
table(LA)
plot(table(LA))
aa2 <- read.delim("clipboard", header = T)
aa2$Sequence <- as.character(aa2$Sequence)
LA2 <- sapply(aa2$Sequence,function(x) substr(x, nchar(x),nchar(x) ) )
plot(table(LA2))
?combn
library(Zhibin)
?find_lipid_combo
library(Zhibin)
?find_lipid_combo
library(Zhibin)
?find_lipid_combo
library(Zhibin)
?find_lipid_combo
library(Zhibin)
?find_lipid_combo
setwd("C:/Users/Zhibin/Dropbox/Project_R_packages/Zhibin")
library(Zhibin)
library(Zhibin)
library(Zhibin)
prcomp_opencpu_csv
library(Zhibin)
install.packages(testthat)
install.packages("testthat")
library(Zhibin)
library(Zhibin)
?prcomp
taxon.table <- USArrests
getwd()
taxon.table <-read.csv("USArrests.tsv")
taxon.table
# readin table
taxon.table <-read.tsv(filename)
?read.csv
taxon.table <-read.csv("USArrests.tsv", sep = "\t")
taxon.table
library(Zhibin)
library(Zhibin)
prcomp_opencpu_csv
library(Zhibin)
prcomp_opencpu_csv
taxon.table
setwd("Z:/Microbiome/eggNOG4.5_database_organize/r_parse_SQL")
# a good tutorial hereL
# https://datacarpentry.org/R-ecology-lesson/05-r-and-databases.html#simple_database_queries
# https://db.rstudio.com/getting-started/database-queries/
library(DBI)
library(RSQLite)
#library(dplyr)
library(dbplyr)
library(tidyverse)
# setup the connection to the database
con = dbConnect(SQLite(), dbname="eggnog.db") # eggnog.db is 21G
species <- "chicken"
blast_mapping <- read_tsv("Chickern_against_eggNOG_bact_acrch_senstive_best.m8", col_names = FALSE)[,1:2]
# Take out the 2nd column as a vector, for databas equery
pro_list <-pull(blast_mapping,2)
# generate the quering sentence
Query <- paste0("SELECT * FROM kegg where name in (",AnnotationDbi::toSQLStringSet(pro_list), ")")
# do the query, using tbl to create a table, and then then convert to tible format
query_result <- as_tibble(tbl(con, sql(eval(Query))))
# join the query result,with the first mapping file
# only keep the column for the orignial protein id and the mapped KO number
query_match <- inner_join(blast_mapping,query_result,by = c("X2" = "name"))[,c(1,3)]
# aggregate to gc formated table
query_result_gc <- aggregate(query_match$X1,by = list(query_match$ko), function(x) paste0(x, collapse = ", ") )
# output the gc file
write_tsv(query_result_gc, paste0("KO_", species,".gc"), col_names = FALSE)
# parsing the og table --------
# only take out the bactNOG and arNOG level entries
og <- as_tibble(tbl(con, sql("SELECT * FROM og where level in ('bactNOG','arNOG')")))
#unique(og$level)
# ____KEGG map -----------------------------------------
og_mapping <- og[,c(7,9)]
# remove the empty lines
og_mapping <- og_mapping[og_mapping$KEGG_freq != "[]",]
# unnest the protein column
og_mapping <- mutate(og_mapping, proteins = strsplit(proteins, ",")) %>% unnest(proteins)
# only keep the matached proteins by joining the query result with the first mapping file
og_mapping_match <- inner_join(blast_mapping,og_mapping,by = c("X2" = "proteins"))[,c(1,3)]
# remove the first and last []
og_mapping_match$KEGG_freq <-substr(og_mapping_match$KEGG_freq, 4,nchar(og_mapping_match$KEGG_freq)-2)
# unnest the KEGG into separate rows
og_mapping_match <- mutate(og_mapping_match, KEGG_freq = strsplit(KEGG_freq, "\\],\\[\"")) %>% unnest(KEGG_freq)
# only use the name and id to replace the KEGG_freq column, using separate
og_mapping_match <- separate(og_mapping_match, KEGG_freq, c("KEGG_freq", "rest"),sep = "\\)\"", remove = TRUE)[,1:2]
#aggregate
og_mapping_match_gc <- aggregate(og_mapping_match$X1,by = list(og_mapping_match$KEGG_freq), function(x) paste0(x, collapse = ", ") )
# split the column tinto
og_mapping_match_gc <- separate(og_mapping_match_gc, Group.1, c("name", "id"),sep = -7, remove = TRUE)[,c(2,1,3)]
# trim the id
og_mapping_match_gc$id <- substring(og_mapping_match_gc$id,3)
# output
write_tsv(og_mapping_match_gc, paste0("KEGG_",species,".gc"), col_names = FALSE)
# ____GO from table -----------------------------------------
og_mapping <- og[,c(6,9)]
# remove the empty lines
og_mapping <- og_mapping[og_mapping$GO_freq != "{}",]
#write_tsv(og_mapping, "GO.tsv")
# unnest the protein column
og_mapping <- mutate(og_mapping, proteins = strsplit(proteins, ",")) %>% unnest(proteins)
# only keep the matached proteins by joining the query result with the first mapping file
og_mapping_match <- inner_join(blast_mapping,og_mapping,by = c("X2" = "proteins"))[,c(1,3)]
# trim, remove the leading and ending extra characters to make it clean
og_mapping_match$GO_freq <- substring(og_mapping_match$GO_freq, 3, nchar(og_mapping_match$GO_freq)-4)
# split and unnest the GO annotation by GO class names
og_mapping_GO_class <- mutate(og_mapping_match, GO_freq = strsplit(GO_freq, "]],\"")) %>% unnest(GO_freq)
# divide into GO CC, BP, MF
query_result_CC <- og_mapping_GO_class[grepl("^Cellular", og_mapping_GO_class$GO_freq),]
query_result_BP <- og_mapping_GO_class[grepl("^Biological", og_mapping_GO_class$GO_freq),]
query_result_MF <- og_mapping_GO_class[grepl("^Molecular", og_mapping_GO_class$GO_freq),]
# remove the leading char
# query_result_CC$GO_freq <- substr(og_mapping_match$GO_freq, 3,nchar(og_mapping_match$GO_freq) -4)
#
#
query_result_CC$GO_freq <- sub("Cellular Component\":\\[\\[\"", "",query_result_CC$GO_freq,)
query_result_BP$GO_freq <- sub("Biological Process\":\\[\\[\"", "",query_result_BP$GO_freq,)
query_result_MF$GO_freq <- sub("Molecular Function\":\\[\\[\"", "",query_result_MF$GO_freq,)
# melt the GO column
query_result_CC_gc <-   mutate(query_result_CC, GO_freq = strsplit(GO_freq, "\\],\\[\"")) %>% unnest(GO_freq)
query_result_BP_gc <-   mutate(query_result_BP, GO_freq = strsplit(GO_freq, "\\],\\[\"")) %>% unnest(GO_freq)
query_result_MF_gc <-   mutate(query_result_MF, GO_freq = strsplit(GO_freq, "\\],\\[\"")) %>% unnest(GO_freq)
# only keep the GO id and name for aggregation
#query_result_CC_gc$GO_freq <-
#t <-  unlist(lapply(query_result_CC_gc$GO_freq, function(x) paste0(unlist(strsplit(x, "\",\""))[1:2], collapse = "_")))
query_result_CC_gc <- separate(query_result_CC_gc, GO_freq, c("GO_ID","Name"),sep = "\",\"", remove = TRUE, extra = "drop")
query_result_BP_gc <- separate(query_result_BP_gc, GO_freq, c("GO_ID","Name"),sep = "\",\"", remove = TRUE, extra = "drop")
query_result_MF_gc <- separate(query_result_MF_gc, GO_freq, c("GO_ID","Name"),sep = "\",\"", remove = TRUE, extra = "drop")
# aggregate, by the ID and name
query_result_CC_gc <- aggregate(X1 ~ GO_ID + Name, query_result_CC_gc, function(x) paste0(x, collapse = ",") )
query_result_BP_gc <- aggregate(X1 ~ GO_ID + Name, query_result_BP_gc, function(x) paste0(x, collapse = ",") )
query_result_MF_gc <- aggregate(X1 ~ GO_ID + Name, query_result_MF_gc, function(x) paste0(x, collapse = ",") )
# output the gc file
write_tsv(query_result_CC_gc, paste0("GOCC_",species,".gc"), col_names = FALSE)
write_tsv(query_result_BP_gc, paste0("GOBP_",species,".gc"), col_names = FALSE)
write_tsv(query_result_MF_gc, paste0("GOMF_",species,".gc"), col_names = FALSE)
# ____NOG from table -----------------------------------------
og_mapping <- og[,c(1,9)]
# unnest the protein column
og_mapping <- mutate(og_mapping, proteins = strsplit(proteins, ",")) %>% unnest(proteins)
# only keep the matached proteins by joining the query result with the first mapping file
og_mapping_match <- inner_join(blast_mapping,og_mapping,by = c("X2" = "proteins"))[,c(1,3)]
# aggregate to gc formated table
og_mapping_match_gc <- aggregate(og_mapping_match$X1,by = list(og_mapping_match$og), function(x) paste0(x, collapse = ", ") )
write_tsv(og_mapping_match_gc, paste0("NOG_",species,".gc"), col_names = FALSE)
# ___Todo, the palm-----------------------------------------
# disconnect the connection ---------------------------------------------
dbDisconnect(con)
setwd("Z:/Microbiome/COG_db_annotation_organize")
library(DBI)
library(RSQLite)
#library(dplyr)
library(dbplyr)
library(tidyverse)
# library(data.table)
# read in the protein <-> COG mapping
#system.time(COG_mapping <- read_tsv("cog2003-2014.csv", col_names = FALSE))
system.time( COG_mapping <-  fread("cog2003-2014.csv")[,c(1,7)])
COG_mapping$V1 <- as.character(COG_mapping$V1)
# species <- "rat"
# system.time(blast_mapping <- fread("rat_against_COG_senstive_Best.m8")[,1:2])
#
# species <- "dog"
# system.time(blast_mapping <- fread("dogs.129_against_COG_senstive_best.m8")[,1:2])
# species <- "pig"
# system.time(blast_mapping <- fread("pig_against_COG_senstive_Best.m8")[,1:2])
species <- "chicken"
system.time(blast_mapping <- fread("Chickern_against_COG_sensitive_best.m8")[,1:2])
#0nly keep the gi id for the cross inference
blast_mapping$V2 <-substr(blast_mapping$V2, 4, 12)
# only keep the matached proteins by joining the query result with the first mapping file
protein_COG <- inner_join(blast_mapping,COG_mapping,by = c("V2" = "V1"))[,c(1,3)]
#aggregate
protein_COG <- aggregate(V1~V7,protein_COG, function(x) paste0(x, collapse = ", ") )
write_tsv(protein_COG, paste0("COG_",species,".gc"), col_names = FALSE)
#system.time(COG_mapping <- read_tsv("cog2003-2014.csv", col_names = FALSE))
system.time( COG_mapping <-  fread("cog2003-2014.csv")[,c(1,7)])
library(DBI)
library(RSQLite)
#library(dplyr)
library(dbplyr)
library(tidyverse)
system.time( COG_mapping <-  fread("cog2003-2014.csv")[,c(1,7)])
COG_mapping$V1 <- as.character(COG_mapping$V1)
library(data.table)
system.time( COG_mapping <-  fread("cog2003-2014.csv")[,c(1,7)])
COG_mapping$V1 <- as.character(COG_mapping$V1)
species <- "chicken"
system.time(blast_mapping <- fread("Chickern_against_COG_sensitive_best.m8")[,1:2])
#0nly keep the gi id for the cross inference
blast_mapping$V2 <-substr(blast_mapping$V2, 4, 12)
# only keep the matached proteins by joining the query result with the first mapping file
protein_COG <- inner_join(blast_mapping,COG_mapping,by = c("V2" = "V1"))[,c(1,3)]
#aggregate
protein_COG <- aggregate(V1~V7,protein_COG, function(x) paste0(x, collapse = ", ") )
write_tsv(protein_COG, paste0("COG_",species,".gc"), col_names = FALSE)
rm(ls <- list())
rm(ls <- ls())
rm(list <- ls())
ls()
rm(ls())
rm(list=ls())
